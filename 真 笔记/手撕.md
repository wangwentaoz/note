1. 防抖
   ```
   function debounce(fn, delay, triggleNow) {
     let timer = null                  // 把timer作为开关，根据timer状态决定下次点击时是否执行
     return (...args) => {
       if(timer) clearTimeout(timer)   
       if(triggleNow){                 // 根据传入的变量判断第一次执行的时候是否立即先执行一次
         var exec = !timer
         timer = setTimeout(() => {    // timer被计时器清除之后并不是null，是计时器的id，所以就不会执行函数
           timer = null
         }, delay)
         if(exec){
           fn.apply(this, args)        // 第一次不进行延迟 
         }
       }else{
         timer = setTimeout(() => {    
           fn.apply(this, args) 
         }, delay)
       }
     }
   }
   ```
   1. 理解：在函数频繁触发是，在规定之间以内，只让最后一次生效
   2. 场景：搜索框实时联想（keyup/input）、按钮点击太快，多次请求（登录、发短信）、窗口调整（resize）
   3. 功能：防抖函数在被调用后，延迟delay毫秒后调用，没到delay时间，你又点了，清空计时器重新计时，直到真的等了delay这么多秒。
   4. 新增功能：第一次没有延迟，并且第一次不执行防抖，先执行一次，后续再次请求才进行防抖
2. 节流
   ```
    function throttle(fn, delay) {
      let timer = null
      let begin = new Date().getTime()
      return (...args) => {
        let cur = new Date().getTime()
        clearTimeout(timer)  
        if(cur - begin >= delay){
          fn.apply(this, args)
          begin = cur
        }else{
          timer = setTimeout(() => {
            fn.apply(this, args)
          }, delay)
        }
        
      }
    }
   ```
   1. 理解：在函数多次频繁触发时，函数执行一次后，只有大于设定的执行周期后才会执行第二次
   2. 场景：页面滚动（scroll）、DOM 元素的拖拽（mousemove）、抢购点击（click）、播放事件算进度信息
   3. 功能：节流函数在设置的delay毫秒内最多执行一次（简单点说就是，我上个锁，不管你点了多少下，时间到了我才解锁）
3. curry柯里化
   ```
    function mycurry(fn, beforeRoundArg = []) {
      return function () {
        let args = [...beforeRoundArg, ...arguments]
        if (args.length < fn.length) {
          return mycurry.call(this, fn, args)
        } else {
          return fn.apply(this, args)
        }
      }
    }

    function sum(a, b, c) {
      return a + b + c
    }

    let sumFn = mycurry(sum)
    console.log(sumFn(1)(2)(3))//6
   ```
4. 数组去重
   ```
    function unique(arr) {
      const res = []
      const obj = {}
      arr.forEach((item) => {
        if (obj[item] === undefined) {
          obj[item] = true
          res.push(item)
        }
      })
      return res
    }
    //其他方法
    //Array.from(new Set(array))
    //[...new Set(array)]
   ```
5. 数组扁平化
   ```
    // 递归展开
    function flattern1(arr) {
      let res = []
      arr.foreach((item) => {
        if (Array.isArray(item)) {
          res.push(...flattern1(item))
        } else {
          res.push(item)
        }
      })
      return res
    }
    // arr.flat(Infinity)
   ```
6. call
   ```
    Function.prototype.myCall = function (obj, ...args) {
      if (obj == undefined || obj == null) {
        obj = globalThis
      }
      obj.fn = this
      let res = obj.fn(...args)
      delete obj.fn
      return res
    }
    value = 2

    let foo = {
      value: 1,
    }

    let bar = function (name, age) {
      console.log(name, age, this.value)
    }

    bar.myCall(foo, 'HearLing', 18) //HearLing 18 1
    bar.myCall(null, 'HearLing', 18) //HearLing 18 2
   ```
   1. 语法：fn.call(obj,...args)
   2. 功能：执行fn，使this为obj，并将后面的n个参数传给fn
7. apply
   ```
    Function.prototype.myAplly = function (obj, arr) {
      if (obj == undefined || obj == null) {
        obj = globalThis
      }
      obj.fn = this
      let res = obj.fn(...arr)
      delete obj.fn
      return res
    }
    value = 2

    let foo = {
      value: 1,
    }

    let bar = function (name, age) {
      console.log(name, age, this.value)
    }

    bar.myAplly(foo, ['HearLing', 18]) //HearLing 18 1
    bar.myAplly(null, ['HearLing', 18]) //HearLing 18 2
   ```
   1. 语法：fn.apply(obj,arr)
   2. 功能：执行fn，使this为obj，并arr数组中元素传给fn
8. bind
   ```
    Function.prototype.myBind = function (obj, ...args) {
      let that = this
      let fn = function () {
        if (this instanceof fn) {
          return new that(...args)
        } else {
          return that.call(obj, ...args)
        }
      }
      return fn
    }

    value = 2

    let foo = {
      value: 1,
    }

    let bar = function (name, age) {
      console.log(name, age, this.value)
    }
    let fn = bar.myBind(foo, 'HearLing', 18)
    //fn() //HearLing 18 1
    let a = new fn() //HearLing 18 undefined
    console.log(a.__proto__)//bar {}
   ```
   1. 语法：fn.bind(obj,...args)
   2. 功能：返回一个新函数，给fn绑定this为obj，并制定参数为后面的n个参数
9. 对象new
   ```
    function newInstance (Fn, ...args) {
      const obj = {}
      obj.__proto__ = Fn.prototype
      const result = Fn.call(obj, ...args)
      // 如果Fn返回的是一个对象类型, 那返回的就不再是obj, 而是Fn返回的对象否则返回obj
      return result instanceof Object ? result : obj
    }
   ```
10. instanceof
   ```
    function instance_of(left, right) {
      let prototype = right.prototype
      while (true) {
        if (left === null) {
          return false
        } else if (left.__proto__ === prototype) {
          return true
        }
        left = left.__proto__
      }
    }
    let a = {}
    console.log(instance_of(a, Object))//true
   ```
11. 浅拷贝
   ```
    // 浅拷贝的方法
    //Object.assign(target,...arr)
    // [...arr]
    // Array.prototype.slice()
    // Array.prototype.concate()

    function cloneShallow(origin) {
      let target = {}
      for (let key in origin) {
        if (origin.hasOwnProperty(key)) {
          target[key] = origin[key]
        }
      }
      return target
    }
    let obj = {
      name: 'lala',
      skill: {
        js: 1,
        css: 2,
      },
    }
    let newobj = cloneShallow(obj)
    newobj.name = 'zhl'
    newobj.skill.js = 99
    console.log(obj)//{ name: 'lala', skill: { js: 99, css: 2 } }
    console.log(newobj)//{ name: 'zhl', skill: { js: 99, css: 2 } }
   ```
12. 深拷贝
   ```
    // 浅拷贝的方法
    //JSON.parse(JSON.stringify(obj))
    function deepClone(target,hashMap=new WeakMap()){
      if(typeof target !== 'object' ||  target==null ){
          if(target instanceof Function) return target.call(this,...arguments)
          return target
      }
      if(target instanceof Date)return new Date(target);
      if(target instanceof RegExp)return new RegExp(target);
      let res = new target.constructor()
      if(hashMap.get(target))return hashMap.get(target)
      hashMap.set(res,target)
      for(let key in target){
          res[key] = deepClone(deepClone(target[key],hashMap))
      }
      return res
    }
    const a = {
    i: Infinity,
    s: "",
    bool: false,
    n: null,
    u: undefined,
    sym: Symbol(),
    obj: {
      i: Infinity,
      s: "",
      bool: false,
      n: null,
      u: undefined,
      sym: Symbol(),
    },
    array: [
      {
        nan: NaN,
        i: Infinity,
        s: "",
        bool: false,
        n: null,
        u: undefined,
        sym: Symbol(),
      },
      123,
    ],
    fn: function () {
      return "fn";
    },
    date: new Date(),
    re: /hi\d/gi,
  };
  let a2 = deepClone(a);
  console.log(a2 !== a);
  console.log(a2.i === a.i);
  console.log(a2.s === a.s);
  console.log(a2.bool === a.bool);
  console.log(a2.n === a.n);
  console.log(a2.u === a.u);
  console.log(a2.sym === a.sym);
  console.log(a2.obj !== a.obj);
  console.log(a2.array !== a.array);
  console.log(a2.array[0] !== a.array[0]);
  console.log(a2.array[0].i === a.array[0].i);
  console.log(a2.array[0].s === a.array[0].s);
  console.log(a2.array[0].bool === a.array[0].bool);
  console.log(a2.array[0].n === a.array[0].n);
  console.log(a2.array[0].u === a.array[0].u);
  console.log(a2.array[0].sym === a.array[0].sym);
  console.log(a2.array[1] === a.array[1]);
  console.log(a2.fn !== a.fn);
  console.log(a2.date !== a.date);
  console.log(a2.re !== a.re);
  // 都要为 true
   ```