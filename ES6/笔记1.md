1. Object.assign
   1. 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。
      ```
      const target = { a: 1, b: 2 };
      const source = { b: 4, c: 5 };
      const returnedTarget = Object.assign(target, source);

      console.log(target);
      // Object { a: 1, b: 4, c: 5 }
      console.log(returnedTarget);
      // Object { a: 1, b: 4, c: 5 }
      ```
2. 只要有return，就可以.then进行处理
3. JavaScript的async/await
   1. async 和 await 在干什么
      1. 一个很有意思的语法规定，await 只能出现在 async 函数中。如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后进入死循环
      2. 如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？
   2. async 的作用
      1. async 函数返回的是一个 Promise 对象。如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。
        ```
        async function testAsync() {
          return "hello async";
        }
        console.log(testAsync());
        //打印
        c:\var\test> node --harmony_async_await .
        Promise { 'hello async' }
        ```
      2. 在最外层可以用then() 链来处理这个 Promise 对象。如果 async 函数没有返回值，它会返回 Promise.resolve(undefined)。
      3. 在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。
   3. await 到底在等啥
      1. await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）
   4. await 等到了要等的，然后呢
      1. 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
      2. 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
   5. async/await 帮我们干了啥
      1. 如果一个函数本身就返回 Promise 对象，加 async 和不加 async 还是有一点点区别：加了 async 之后外面得到 Promise 对象并不是 return 的那一个，参阅代码：
        ```
        (() => {
          let promise;
          async function test() {
            promise = new Promise(resolve => resolve(0));
            promise.mark = "hello";
            return promise;
          }

          const gotPromise = test();
          console.log(`is same object?: ${promise === gotPromise}`);  // false
          console.log(`promise.mark: ${promise.mark}`);               // hello
          console.log(`gotPromise.mark: ${gotPromise.mark}`);         // undefined
        })();
        ```
      2. async/await 的优势在于处理 then 链 和 解决Promise的传参问题
        ```
        function takeLongTime(n) {
          return new Promise(resolve => {
            setTimeout(() => resolve(n + 200), n);
          });
        }

        function step1(n) {
          return takeLongTime(n);
        }
        function step2(m, n) {
          return takeLongTime(m + n);
        }
        function step3(k, m, n) {
          return takeLongTime(k + m + n);
        }

        用 async/await 来写：
        async function doIt() {
          console.time("doIt");
          const time1 = 300;
          const time2 = await step1(time1);
          const time3 = await step2(time1, time2);
          const result = await step3(time1, time2, time3);
          console.log(`result is ${result}`);
          console.timeEnd("doIt");
        }
        doIt();
        写成 Promise 方式

        function doIt() {
          console.time("doIt");
          const time1 = 300;
          step1(time1)
          .then(time2 => {
            //这里因为都在中括号的作用域中，所以可以取到time2，而因为time1是const定义的变量，所以可以直接拿到。并且可以直接使用.then函数，在之其中return 了一个数组，外面可以继续使用.then函数，只不过是同步的。在外面的作用域中就取不到time2了。
              return step2(time1, time2)
              .then(time3 => [time1, time2, time3]);
          })
          .then(times => {
              const [time1, time2, time3] = times;
              return step3(time1, time2, time3);
          })
          .then(result => {
              console.log(`result is ${result}`);
          });
        }
        doIt();
        ```
4. for循环的作用域问题
   1. for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
      ```
      for (let i = 0; i < 3; i++) {
        let i = 'abc';
        console.log(i);
      }
      ```
   2. 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。
   3. 也就是说for循环外面有一个全局作用域，for()小括号内是外面作用域的第二层， {}中括号内是子作用域。
      ```
      if(true) let x = 1
      特殊的是没有中括号，没有子作用域，而if语句作用于全局作用域的第二层
      let只能出现在当前作用域的顶层，所以在这里会报错
      ```
5. Object.keys(obj)
   1. Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
   2. 后面可以接一个.forEach用来循环这个对象的所有属性
      ```
      Object.keys(obj).forEach( (key, i) => {
        obj[key]
      });
      ```
6. Object.setPrototypeOf(obj1, obj2);
   1. 设置obj1的原型为obj2
7. window.open('#/hotelReport')
   1. 通过新窗口打开新的路由，只需要在router的index.js文件中配置一下router就行了，
      ```
      例如
      {
         path: '/hotelReport',
         component: () => import('@/views/integratedManagePlatform/financialManagement/reportCenter/report/hotelReport'),
         hidden: true,
         meta: {
            title: '酒店报表'
         },
      },
      ```
8. [].slice.call()的思考
   1. [].slice是一个函数,函数可以调用call方法.
   2. 通过call(),认arrayLike具有数组slice方法,而数组slice()会返回数组,间接认arrayLike调用slice()后最终返回数组
   3. 假如认call()带上参数如:let arr2 = [].slice.call(arrayLike, 1, 2); //['b']
   4. 与下面这行代码运行结果是一样let arr3 = ['a','b','c'].slice(1,2) //['b']
   5. 可以发现call()的第二参数和第三参数是arrayLike调用slice()时传给slice()的参数
      ```
      let arrayLike = {
          '0': 'a',
          '1': 'b',
          '2': 'c',
          length: 3
      };
      let arr1 = [].slice.call(arrayLike);
      arr1 //['a','b','c']
      ```
9. 函数的解构赋值
   1. vue 中 @click = func 和 @click = func() 的区别
      1. @click = func 没有参数传下去，不可以用解构赋值
      2. @click = func() 传的参数为空，可以用解构赋值
10. 对象的解构赋值连续写法
    1. const {keyWordElement:{value}} = this
    2. value值表示this.keyWordElement.value 
    3. 但是keyWordElement是没有定义的