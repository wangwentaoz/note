## 深入组件-2
1. 插槽
   1. 具名插槽
      1. 一个不带 name 的 <slot> 出口会带有隐含的名字“default”
      2. 通过name可以为不同的插槽分配独立的 ID，也就能够以此来决定内容应该渲染到什么地方：
        ```
        base-layout 组件
        <slot name="header"></slot>
        ```
      3. 在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：
        ```
        <base-layout>
          <template v-slot:header>
            <h1>Here might be a page title</h1>
          </template>
        </base-layout>
        ```
   2. 作用域插槽
      1. 插槽内容能够访问子组件中才有的数据是很有用的
      2. 要使 item 在父级提供的插槽内容上可用，我们可以添加一个 <slot> 元素并将其作为一个 attribute 绑定：
        ```
         <slot :item="item"></slot>
        ```
      3. 绑定在 <slot> 元素上的 attribute 被称为插槽 prop
         1. 要使 item 在父级提供的插槽内容上可用，我们可以添加一个 <slot> 元素并将其作为一个 attribute 绑定
        ```
        三种写法都可以
        <todo-list v-slot:default="slotProps" v-slot="slotProps">
          <template v-slot:default="slotProps">
            {{ slotProps.item }}
          </template>
        </todo-list>
        ```
      4. 默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：
        ```
        <!-- 无效，会导致警告 -->
        <todo-list v-slot="slotProps">
          <template v-slot:other="otherSlotProps">
            slotProps 在此处不可用
          </template>
        </todo-list>
        ```
      5. 只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法
   3. 动态插槽名
      ```
      <base-layout>
        <template v-slot:[dynamicSlotName]>
          ...
        </template>
      </base-layout>
      ```
   4. 具名插槽的缩写
      1. 把参数之前的所有内容 (v-slot:) 替换为字符 #
        ```
        <base-layout>
          <template #header>
            <h1>Here might be a page title</h1>
          </template>
        </base-layout>
        ```
      2. 然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：
        ```
        <todo-list #="{ item }"> </todo-list>
        ```
      3. 如果希望使用缩写的话，你必须始终以明确的插槽名取而代之：
        ```
        <todo-list #default="{ item }"> </todo-list>
        ```
2. Provide / Inject
   1. 无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。
      1. 父组件有一个 provide 选项来提供数据
      2. 子组件有一个 inject 选项来开始使用这些数据
      3. 如果我们尝试在此处 provide 一些组件的实例 property，这将是不起作用的
         1. 要访问组件实例 property，我们需要将 provide 转换为返回对象的函数
        ```
        provide: {
          todoLength: this.todos.length // 将会导致错误 `Cannot read property 'length' of undefined`
        },
        // 函数形式
        provide() {
          return {
            todoLength: this.todos.length
          }
        },
        // 子组件
        inject: ['todoLength']
        ```
   2. 处理响应性
      1. 默认情况下，provide/inject 绑定并不是响应式的
         1. 我们可以通过传递一个 ref property 或 reactive 对象给 provide 来改变这种行为
            ```
            provide() {
              return {
                todoLength: Vue.computed(() => this.todos.length)
              }
            }
            ```
3. 动态组件 & 异步组件
   1. 在动态组件上使用 keep-alive
      1. 我们之前曾经在一个多标签的界面中使用 is attribute 来切换不同的组件：
         1. 每次切换组件的时候，Vue 都创建了一个新的 currentTabComponent 实例。
        ```
        <component :is="currentTabComponent"></component>
        ```
      2. 当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复渲染导致的性能问题
      3. 我们可以用一个 <keep-alive> 元素将其动态组件包裹起来
        ```
        <!-- 失活的组件将会被缓存！-->
        <keep-alive>
          <component :is="currentTabComponent"></component>
        </keep-alive>
        ```
   2. 异步组件
      1. 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块
      2. 为了实现这个效果，Vue 有一个 defineAsyncComponent 方法：
        ```
        import { defineAsyncComponent } from 'vue'
        const { createApp, defineAsyncComponent } = Vue
        const app = createApp({})
        const AsyncComp = defineAsyncComponent(
          () =>
            new Promise((resolve, reject) => {
              resolve({
                template: '<div>I am async!</div>'
              })
            })
        )

        const AsyncComp = defineAsyncComponent(() =>
          import('./components/AsyncComponent.vue')
        )
        app.component('async-example', AsyncComp)
        
        当在局部注册组件时
        components: {
          AsyncComponent: defineAsyncComponent(() =>
            import('./components/AsyncComponent.vue')
          )
        }
        ```
         1. 此方法接受一个返回 Promise 的工厂函数
         2. 从服务器检索组件定义后，应调用 Promise 的 resolve 回调。你也可以调用 reject(reason)，来表示加载失败
4. 模板引用
   1. 尽管存在 prop 和事件，但有时你可能仍然需要在 JavaScript 中直接访问子组件
   2. 可以使用 ref attribute 为子组件或 HTML 元素指定引用 ID
      ```
      <input ref="input" />
      this.$refs.input.focus()
      ```
   3. $refs 只会在组件渲染完成之后生效。这仅作为一个用于直接操作子元素的“逃生舱”——你应该避免在模板或计算属性中访问 $refs
5. 处理边界情况
   1. 控制更新