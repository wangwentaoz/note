# 1.移动web-流式布局
1. 浏览器现状
   1. uc、qq、谷歌、搜狗等，主要都是webkit内核浏览器改来的，兼容性很好 
   2. 手机屏
      1. 尺寸多，碎片化严重。分辨率种类多，开发者不需要关注，因为常用的是px
      2. 不建议纠结dp、pt、dpi、ppi、等单位
   3. 调试方法
      1. 谷歌浏览器的模拟手机调试
      2. 搭建本地服务器，手机和服务器在同一个局域网，通过手机访问服务器。
      3. 使用外网服务器，直接ip或域名访问。
2. 视口
   1. 浏览器显示页面内容的屏幕区域，视口可以分为布局视口、理想视口、视觉视口
      1. 布局视口
         1. 目的是解决早期的pc端页面在手机上显示的问题
         2. ios，Android基本将这个视口分辨率设置为980px，所以pc端网页都能在手机上显示，只不过元素上看上去很小一般默认可以通过手动缩放网页。一般不用
      2. 视觉视口
         1. 用户正在看到的网站的区域
         2. 可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度
      3. 理想视口
         1. 使网站在移动端有最理想的浏览和阅读宽度而设定。
         2. 需要手动添写meta视口标签通知浏览器操作 
         3. meta视口标签的目的就是想让布局视口的宽度和理想视口的宽度一致，简单理解就是设备有多宽，布局视口就多宽。
   2. meta视口标签
      1. 标准的viewport设置：<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
      2. name表示为视口标签，content内容里面包含属性
         1. width：设置的是视口的宽度，device-width特殊值表示为设备的宽度
         2. user-scalabel：用户是否缩放，属性值可以为yes，1，no，0表示是否允许
         3. initial-scale：初始缩放比
         4. maximum-scale：最大缩放比
         5. minimum-scale：最小缩放比
   3. 二倍图
      1. 物理像素、物理像素比
         1. 物理像素指的是屏幕的最小颗粒，是物理真是存在的。
         2. 我们开发的1px不一定等于1个物理像素
         3. pc端1px等于1个物理像素，移动端不尽相同
         4. 1px能显示的物理像素点的个数，称为物理像素比或者屏幕像素比
         5. pc端和早期的移动端1css像素等于1物理像素，手机的retina（视网膜屏幕）是一种显示技术，可以将更多的像素点压缩至一块屏幕里，即一个css像素等于多个物理像素，从而达到更高的分辨率，提高屏幕显示的细腻程度。
      2. 多倍图
         1. 对于50px*50px的图片，在手机retina屏中打开，会物理放大数倍，造成图片模糊
         2. 在标准的viewport设置中（上面讲的），用倍图提高图片质量，解决高清设备中的模糊问题。
         3. 通常使用二倍图，因为iPhone6、7、8的影响，但是现在还存在三倍图四倍图的情况。
         4. 背景图片注意缩放问题
         5. 二倍图这里实际就是采用一个100* 100px的图片手动缩小到50* 50px，即准备的图片比实际需要的大小 大两倍，称为2倍图。
3. 移动端主流方案
   1. 单独制作移动端页面（主流）
      1. 通常情况，网址域名前加m（mobile）可以打开移动端。通过判断设备，如果是移动端设备打开就跳到移动端页面。例m.vscode.com
   2. 响应式页面兼容移动端
      1. 通过判断屏幕宽度改变样式，以适应不同终端
      2. 制作麻烦，需要花大力气去调试兼容性问题
4. 移动端技术解决方案
   1. 移动端浏览器
      1. 基本以webkit内核为主，因此就只考虑webkit兼容性问题。可以放心用h5、cs样式。同时浏览器的私有前缀只考虑添加weibkit即可。
   2. css初始化normalize.css
      1. 保护了有价值的默认值，修复了浏览器bug。
      2. 是模块化的，拥有详细的文档
      3. http://necolas.github.io/normalize.css/
   3. 特殊样式
      1. 盒子模型box-sizing
      2. 点击高亮(手机上点击后有背景)我们需要清除，设置为transparent完成透明
         1. -webkit-tap-highlight-color:transparent
      3. 移动浏览器默认外观在ios上加上这个属性才能给按钮和输入框自定义样式
         1. input{-webkit-appearance：none}
      4. 禁用长按页面时的弹出菜单
         1. img，a{-webkit-touch-callout：none；}
   4. 常见布局
      1. 单独制作移动端页面
         1. 流式布局（百分比布局）
         2. flex弹性布局
         3. less+rem+媒体查询布局
         4. 混合布局
      2. 响应式页面兼容移动端
         1. 媒体查询
         2. bootstarp
# 2.布局
1. 流式布局（百分比布局）
   1.  也称非固定像素布局，通过设置盒子的宽度为百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充。
       1.  max-width：最大宽度max-height
       2.  min-width：最小宽度min-height
   2. 移动端精灵图需要先把原图缩放一半，然后再测位置。因为通常是二倍图放入移动端的。
2. flex布局
   1. 传统布局与flex布局
      1. 传统布局
         1. 兼容性好
         2. 布局繁琐
         3. 局限性，移动端布局效果不行
      2. flex布局
         1. 布局简单
         2. pc端支持性差
         3. ie11或者更低的版本，不支持或部分支持
         4. 不分块级元素行级元素，也没有浮动定位
   2. flex（弹性）布局原理
      1. 任何一个容器都可以指定为flex布局
      2. 当我们为父元素设置flex布局时，子元素的float、clear、vertical-align属性失效。
      3. 采用flex布局的元素称为flex容器。他的所有子元素自动成为容器成员，称为flex目。
      4. 通过给父盒子添加flex属性，来控制子盒子的位置和排列方式
   3. flex布局容器常见属性
      1. flex-direction：设置主轴方向
         1. flex布局中分为主轴和侧轴两个方向。默认主轴方向就是x轴方向，水平向右，默认侧轴方向就是y轴方向，水平向下。可以设定。主轴侧轴是会变化的，flex-direction设置谁为主轴，剩下的就是侧轴，子元素跟着主轴排列
         2. row:从左到右。默认值
         3. row-reverse：从右到左
         4. column：从上到下
         5. column-reverse：从下到上
      2. flex-wrap：设置子元素是否换行（多行）
         1. nowrap：不换行，默认属性，项目都排在一条线轴线上
         2. wrap：换行
      3. justify-content：设置主轴上子元素排列方式
         1. 定义了项目在主轴上的对齐方式，一定要确定好谁为主轴
         2. flex-start：默认值，从头部开始
         3. flex-end：从尾部开始
         4. center：主轴中居中对齐，主轴为x轴则居中对齐
         5. space-around：平分剩余空间
         6. space-between：先两边贴边，在平分剩余空间 
      4. align-items：设置侧轴上（默认y轴）子元素排列方式（单行）
         1. flex-start：从上到下
         2. flex-end：从下到上
         3. center：居中（垂直居中）
         4. stretch：拉伸（默认值），但是子盒子不要给高度，拉到和父盒子一样高。
      5. align-content：设置侧轴上子元素排列方式（多行）
         1. 设置子项在侧轴上的排列方式，并且只能用于子项出现换行的情况（多行），在单行时是没有效果的
         2. flex-start：默认值，在侧轴的头部开始排列
         2. flex-end：在侧轴的尾部开始排列
         3. center：在侧轴中间显示
         4. space-around：子项在侧轴平分剩余空间
         6. space-between：子项在侧轴先   两边贴边，在平分剩余空间 
         5. stretch：拉伸（默认值）
      6. flex-flow：复合属性
         1. flex-flow：row wrap； 
   4. flex布局子项常见属性
      1. flex：定义子项目分配剩余空间，用flex表示占多少分
         1. flex：number；默认值为0，不占份数。可以写百分比，相对于父盒子，如果父元素没有高度，那高度就不用平分，内容撑开
      2. align-self：控制子项自己在侧轴的排列方式
         1. 允许单个项目有和其他项目不一样的对齐方式。
         2. 默认值auto表示继承父元素，如果没有父元素，等同于stretch
      3. order属性定义子项的排列顺序（前后顺序）
         1. 数值越小，排列越靠前，默认为0，可以为负数
   5. 背景渐变
      1. 背景线性渐变
         1. 必须添加浏览器私有前缀
         2. background：-webkit-linear-gradient（起始方向，颜色1，颜色2等等）
         3. 起始方向可以写方位名词或度数，默认为top，也可以把左上角写为left top
3. rem布局
   1. rem基础
      1. 布局文字随着屏幕大小改变
      2. 流式布局和flex布局主要针对宽度布局，屏幕改变宽度改变，屏幕变化时让宽度高度同时改变大小
      3. 单位，rem（root em）是一个相对单位，类似于em，em是相对于父元素字体大小。
      4. rem是相对于 html元素 的 字体大小。
      5. 优势：可以通过修改 页面中html元素的字体大小 来改变页面中元素的大小 来整体控制
   2. 媒体查询
      1. meidia query 是css3新语法，@media查询可以针对不同媒体类型、屏幕尺寸设置不同的样式。当重置浏览器大小的过程中，页面也会根据浏览器的宽高重新渲染页面。
      2. @media mediatype and|not|only （media feature）{CSS-Code}
      3. mediatype媒体类型
         1. all：所有设备
         2. print：用于打印机或者打印预览
         3. screen：电脑屏幕，平板，手机
      4. 关键字，将媒体类型和媒体特性连接到一起作为媒体查询的条件
         1. and：且
         2. not：非
         3. only：指定某个特定  媒体类型  ，可省略
      5. media feature媒体特性
         1. 每种媒体都有不同的特性，这里只介绍几个常用的
         2. width：定义输出设备中页面可见区域的宽度
         3. min-width：注意这里是包含等于号的
         4. max-width：包含等于号，即max-width：800px表示800px是可以的
      6. 在屏幕上并且最大宽度为800px上，最小宽度为500px，就把html字体改为100px
         1. @media screen and (max-width:800px) and (min-width：500px) {html{font-size：100px；}}
         2. 这里也可以用到css层叠性，后面的可以层叠到前面的，在设置阶梯宽度可以用到。这时候写代码需要从范围的大到小写，这样后面范围小，控制更精确，层叠的时候可以覆盖前面的，没覆盖的就是原来的样式。
         3. screen和and不能省略
      7. 引入资源
         1. 当样式比较繁多，可以针对不同的媒体使用不同的样式表，直接在link中判断设备的尺寸，然后引用不同的资源
         2. <link rel="stylesheet" media="mediatype and|not|only (media feature)" href="链接">
         3. 媒体查询也适合从范围大到范围小，范围小的把范围大的重叠区域给覆盖掉
   3. less基础
      1. css弊端
         1. css是非程序式语言，没有变量，函数作用域的概念，冗余度高，不利于扩展和复用。没有很好的计算能力，不可以写乘除法。
      2. less（leaner style sheets）
         1. 是一门css扩展语言，也成为css预处理器，即在css的现有语法上为css语言增加程序式语言的特性
         2. 引入了变量，mixin（混入），运算以及函数功能。
         3. 网址https://lesscss.cn/
         4. 常见css预处理器sass，less，stylus
         5. 新建一个.less后缀名的文件
      3. less变量
         1. @变量名：值； 规范：不能有特殊字符，大小写敏感，变量名不可以 以数字开头，
         2. 例@color：red；  定义变量
         3. body{background：@color；}   和css一样
      4. less编译
         1. less包含一套自定义的语法和解析器，用户根据这些语法定义自己的样式规则，然后通过编译器生成css文件。
         2. 所以需要把less文件编译生成css文件
         3. vscode中的easy less插件可以用于编译器，只需要保存一下less文件就会自动生成css文件
      5. less嵌套
         1. 子元素的样式直接写到父元素里
            1. 例a是header的子元素 .header{width:200px;color:green; a{color:red;}}
         2. 交集、伪类、伪元素选择器
            1. 如果内层选择器没有&符号，就解析成为父选择器后代
            2. 如果有，被解析为父元素自身或者父元素伪类
               1. 例 a{ &：hover{color：green；} }
      6. less运算
         1. 任何数字、颜色、变量都可以运算，+，-，*，/。
         2. 运算符中间左右有个空格隔开，例如5px + 5
         3. 两个数运算，如果只有一个有单位，结果就以其为单位
         4. 如果两个数运算，且都有单位，以第一个的单位为准
   4. rem适配方案
      1. 原理
         1. 让一些不能等比自适应的元素，达到当设备尺寸发生变化时，等比例适配当前设备
         2. 使用媒体查询根据不同设备按比例设置htlml字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化时元素尺寸也发生变化，从而达到等比例适配。
      2. rem实际开发适配方案
         1. 按设计稿与设备宽度的比例，动态计算并设置html根元素的font-size大小（媒体查询）
         2. css中，设计稿元素的宽、高、相对位置等取值按照同等比例换算为rem为单位的值。
      3. 适配方案技术
         1. less+媒体查询+rem
            1. 设计稿常见尺寸宽度
               1. iPhone678为750px
               2. Android大部分4.7~5寸的安卓设备为720px
               3. 一般以一套两套效果图适应大部分屏幕，放弃极端屏或者对其优雅降级，牺牲一些效果，基本以750为准
               4. 手机屏幕大部分都是几个固定的宽度，只是前面两种宽度比较常见
            2. 动态设置html标签font-size大小
               1. 假设设计稿为750px
               2. 把整个屏幕划分15等份，也可以是10或20份
               3. 每一份作为html字体大小，这里就是50px
               4. 那么在320px设备时，字体大小就是320/15=21.33
               5. 用页面元素的大小除以不同的html字体大小会发现其比例是相同的
               6. 比如以750为标准 的设计稿
               7. 一个100*100像素的页面元素在750屏幕下就是100/50=2rem * 2rem，宽高比为1：1
               8. 320屏幕下，html字体大小为21.33，2rem=42.66px，此时宽高都是42.66，宽高比为1：1
               9. 已经实现了不同屏幕下页面元素盒子等比例缩放的效果
            3.  元素大小取值方法
                1.  页面元素的rem值=页面元素值（px）/（屏幕宽度/划分的份数）
                2.  屏幕宽度/划分的份数 = html的字体大小font-size
                3.  前面先写上html{font-size：50px；}，当页面从电脑打开移动端首页 页面尺寸比较大的时候不能分为15份了，要直接固定大小，一定写到最上面,利用层叠性,
         2. flexible.js+rem  推荐，更简单
            1. flexible.js
               1. 手机淘宝出的移动端适配库，不需要写不同屏幕下的媒体查询，因为里面做了js处理
               2. 原理是把当前设备划分10等份，不同设备下比例还是一致的。
               3. 我们只需要确定当前设备的html文字大小就可以了
               4. 例如当前设计稿为750px，我们只需把html文字大小设置为75px，里面页面元素rem值：px/75，剩余的让flexible.js算。
               5. git地址：https://github.com/amfe/lib-flexible
            2. 插件cssrem
               1. 可以直接把尺寸px修改为rem
               2. 这时需要设置基准值，在设置里面搜索cssroot，把默认html字体大小修改为设定的单位大小，例如750/10=75px，这时写px单位的时候可以直接用插件转换成rem为单位
4. 响应式布局
   1. 响应式开发
      1. 原理：就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。一套页面针对不同的终端
         1. 优点
            1. 不需要单独写移动端页面
            2. 相应不同设备发生变化，pc，pad，移动端
         2. 设备划分
            1. 超小屏幕（手机）：<768px                     设置宽度为100%  
            2. 小屏设备（平板）：>=768px ~ <992px           设置宽度为750px
            3. 中等屏幕（桌面显示器）：>=992px ~ <1200px    设置宽度为970px
            4. 宽屏设备（大桌面显示器）：>=1200px            设置宽度为1170px
      2. 响应式布局容器
         1. 响应式需要一个父级作为布局容器，来配合子级元素实现变化效果
         2. 原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。
         3. 布局容器居中显示，两边留白，margin：0 auto；
            ```
            .container{
               height:150px;
               margin:0 auto;
               background:#fff;
            }
            @media screen and (max-width:767px){
               .container{
                  width:100%;
               }
            }
            @media screen and (min-width:768px){
               .container{
                  width:750px;
               }
            }
            @media screen and (min-width:992px){
               .container{
                  width:970px;
               }
            }
            @media screen and (min-width:1200px){
               .container{
                  width:1170px;
               }
            }
            ```
   2. bootstrap开发框架
      1. 简介
         1. 来自twitter，基于html，css，js，简介灵活。
         2. 官网        https://getbootstrap.com/
         3. 中文官网    https://www.bootcss.com/
         4. 推荐使用    https://bootstrap.css88.com/
      2. 使用
         1. 创建文件夹结构，即创建bootstrap专门的文件夹
         2. 创建html骨架结构
         3. 引入相关样式文件
         4. 书写内容