1. 垃圾回收
   1. 调用栈中的数据是如何回收的
   2. 堆中的数据是如何回收的
      1. 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象
         1. 新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了
         2. 副垃圾回收器，主要负责新生代的垃圾回收
            1. 新生代中用 Scavenge 算法来处理
            2. 对象区域、空闲区域
         3. 主垃圾回收器，主要负责老生代的垃圾回收
            1. 主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的
      2. 垃圾回收器的工作流程
         1. 第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象
         2. 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象
         3. 第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器
   3. 全停顿
      1. 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）
2. ⽤户输⼊URL回⻋
   1. 判断输⼊的是否为搜索内容还是请求的URL
      1. 如果是搜索内容，地址栏会使⽤浏览器默认的搜索引擎来合成带关键字的URL
      2. 如果是符合URL规则的内容，地址栏会根据规则，加上协议合成完成的URL
   2. 在回⻋前，会执⾏当前⻚⾯beforeunload
      1. beforeunload允许在退出之前执⾏⼀些数据清理
      2. 可以询问⽤户是否要离开当前⻚⾯
      3. 可以让浏览器取消导航
   3. 同意跳转或未监听beforeunload事件
      1. 加载新的地址
      2. 标签页上的图标进入加载状态
      3. 等待⽂档提交阶段
3. 浏览器进程将该URL通过IPC转发给⽹络进程
   1. ⽹络进程先检查判断是否使⽤缓存
      1. Service Worker 、强缓存/协商缓存、Push Cache推送缓存
      2. 浏览器在加载资源时
         1. 根据资源的⾸部判断是否命中强缓存 （Cache-Control/Expires）
            1. Cache-Control
               1. 优先级⼤于Expires
               2. max-age 资源有效时间（秒）
               3. no-cache 协商缓存
               4. no-store 禁⽌缓存
               5. public 所有⽤户都可缓存
               6. private 终端浏览器缓存
            2. Expires
               1. 值是⼀个绝对时间，表示资源的失效时间
               2. 缺点 服务器与客户端时间偏差较⼤导致缓存混乱
            3. 如果命中，浏览器直接从缓存中读取资源
            4. 没有命中，浏览器会发送请求到服务器
         2. 当Cache-Control=no-cache时，服务器通过⾸部判断是否命中协商缓存（Last-Modified/If-Modified-Since 与 ETag/If-None-Match）
            1. Last-Modified/If-Modified-Since
               1. Last-Modified表示该资源最后修改的时间
               2. 再次请求资源时，请求头中会包含If-Modified-Since，该值为缓存之前返回的Last-Modified
               3. 服务器在接收到后也会做比对，如果相同则命中协商缓存
               4. 如果命中，服务器返回304并不反回资源也不反回Last-Modified。继续使⽤缓存
               5. 没有命中，重新发起请求
               6. 缺点 短时间内资源发⽣了改变，Last-Modified并不会发⽣变化
            2. ETag/If-None-Match
               1. ETag资源的唯⼀标识，资源改变时ETag会发⽣变化
               2. 再次请求资源时，请求头中会包含ETag/If-None-Match，该值为缓存之前返回的ETag
               3. 服务器判断是否命中协商缓存
               4. 如果命中，服务器返回304并不反回资源，但会将ETag返回。继续使⽤缓存
               5. 没有命中，重新发起请求
         3. 当Cache-Control=no-store时 禁⽌使⽤缓存
   2. ⽹络进程发起真正的URL请求
      1. 如果是HTTPS协议 需要建⽴TLS连接
      2. 进⾏DNS解析以获取服务器IP地址
         1. ⾸先搜索浏览器的DNS缓存，缓存中维护⼀张域名与IP地址的表
         2. 没有命中，在操作系统中hosts⽂件搜索
         3. 没有命中，则将域名发送⾄本地域名服务器，本地域名服务器将通过递归查询⾃⼰的DNS缓存
         4. 没有命中，则本地域名服务器向上级域名服务器进⾏迭代查询
            1. 本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地域名服务器
            2. 本地域名服务器拿到这个顶级域名服务器的地址后，向其发起请求，获取权限域名服务器的地址
            3. 本地域名服务器根据权限域名服务器的地址，向其发起请求，最终得到对应的IP地址
         5. 本地域名服务器得到IP地址返回给操作系统，同时将IP缓存起来
         6. 操作系统将IP返回给浏览器，也将IP缓存起来
         7. 浏览器得到了对应IP地址，也将IP缓存起来
   3. 建⽴TCP连接 三次握⼿
      1. 客户端⾸先发送⼀个带SYN标志的数据包给对⽅（序号为J），并进入SYN_SEND状态
      2. 服务器接收到数据包SYN　J后，会确认该数据包已经收到并回传⼀个带有ACK　J＋１标志位和SYN　Ｋ的数据包，服务器进入SYN_RECV状态
      3. 最后，客户端进入链接状态后，向服务器回传⼀个带有ACK　K＋１标志的数据包确认客户端已收到建立确认链接，服务器收到ACK标志位后，服务端进入链接已建立状态
   4. 发起请求
      1. 构建请求 请求⾏、请求头、相关的Cookie附加到请求头中
      2. 向服务器发送请求
4. ⽹络进程接收到响应头数据，解析数据转发给浏览器进程
   1. 服务器接收到请求后，⽣成响应数据（响应⾏、响应头、响应体）
   2. 并发给⽹络进程
5. 浏览器进程接收到响应头数据后，发送提交导航消息到渲染进程
   1. 如果Connection是keep-alive服务器保持TCP连接
   2. 如果没有或是Close则关闭TCP连接 四次挥⼿　　　客户端或者服务端都能主动发起关闭链接请求
      1. 第⼀次挥⼿ 客户端发送⼀个**FIN报⽂**（连续释放报⽂段），报⽂中指定⼀个序列号。此时客户端处于FIN_WAIT1状态
      2. 第⼆次挥⼿ 服务端接收到**FIN之后，会发送ACK**报⽂（确认报⽂段），且将客户端的序列号+1作为ACK报⽂的序列号值，表明已经收到客户端的报⽂了，此时服务端处于CLOSE_WAIT状态。此时服务端不能马上关闭链接，需要检查是否还有未处理完成的数据
      3. 第三次挥⼿ 如果服务端处理完成所有数据，和客户端第⼀次挥⼿⼀样发送**FIN**报⽂(连续释放报⽂段），且指定⼀个序列号。此时服务端处于LAST_ACK状态
      4. 第四次挥⼿ 客户端接收到**FIN报⽂，⼀样发送⼀个ACK**报⽂作为应答，且把服务端的序列号+1作为⾃⼰的ACK报⽂的序列号值，此时客户端处于TIME_WAIT状态。过⼀段时间（2MSL），确保服务端收到⾃⼰的ACK报⽂后进⼊CLOSED状态。服务端接收到ACK报⽂后就处于CLOSED状态了。
   3. 如果状态码是301、302，读取响应头中的Location字段重新定向地址，重新发起请求。
   4. 如果是200，可以继续处理该请求
   5. 响应头的 Content-Type的值，根据不同的资源类型采⽤不同的解析⽅式
      1. text/html 告诉浏览器是HTML格式
      2. application/octet-stream 告诉浏览器是字节流类型，通常按照下载类型处理该请求
      3. 如果是下载类型application/octet-stream，该请求会被提交给下载管理器，URL请求的导航流程到此结束
      4. 如果是HTML则会继续进⾏导航流程
      5. Chrome的默认策略：⼀个标签对应⼀个渲染进程，如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程
6. 渲染进程接收到提交导航消息后，便准备接收HTML等类型数据，接收数据的⽅式时直接和⽹络进程建⽴数据通道
7. 等文档数据传输完成之后渲染进程会向浏览器进程确认提交，告诉浏览器进程已经准备好接收和解析⻚⾯数据
8. 浏览器进程接收到渲染进程的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面
9. 渲染阶段：一旦文档被提交，渲染进程便开始页面解析和子资源加载了
   1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构
   2. 样式计算：解析 CSS ，如果是style标签则开始解析CSS，如果是link标签则优先异步下载后解析CSS，⽣成CSS 规则树
   3. 遇到script标签，⾏内直接执⾏，如果是src引⼊则同步下载脚本⽂件，⽴即执⾏
      1. 普通script标签
         1. 如果携带 async 属性，异步加载，打断⻚⾯解析，同步执⾏
         2. 如果携带 defer，异步加载，等⻚⾯解析完成后，同步执⾏
         3. async优先级⼤于defer
      2. es6 type=module标签
         1. 异步加载，等⻚⾯解析完成后，同步执⾏ 等同于defer
         2. 如果携带async属性，异步加载及所有依赖项 打断⻚⾯解析 同步执⾏
   4. 合并 DOM 树和 CSS 规则树，⽣成 render 树（ Layout / reflow ），并计算元素的布局信息
   5. 对布局树进行分层，并生成分层树。
      1. 渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树
   6. 为每个图层生成绘制列表，并将其提交到合成线程
      1. 绘制 render 树（paint），在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，绘制⻚⾯像素信息。
      2. 把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
   7. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
      1. 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图
   8. 合成线程就会生成一个绘制图块的命令——“DrawQuad”提交给浏览器进程
   9. 浏览器进程根据 DrawQuad 消息生成页面绘制到内存中，并显示到显示器上
10. 相关概念
    1. 更新了元素的几何属性（重排）
       1. 从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排
       2. 重排需要更新完整的渲染流水线，所以开销也是最大的
    2. 更新元素的绘制属性（重绘）
       1. 如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘
       2. 相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
    3. 直接合成阶段
       1. 那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成
       2. 我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。
       3. 这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。