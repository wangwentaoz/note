# JavaScript
## 1、浏览器组成
1. shell部分
2. 内核部分
   1. 渲染引擎：语法规则和渲染，渲染是从屏幕自上而下渲染的
   2. js引擎
   3. 其他模块
3. 历史
   1. 08年google发布chrome，采用优化后的js引擎，能直接把js代码转为机械码执行
## 2、js的特点
1. 解释性语言 
   1. 读一行翻译一行执行一行，速度相比较慢。跨平台，
   2. 编译型语言是全都读完然后再翻译，速度快，可以开发底层的东西，引擎等。不跨平台，移植性不好。
   3. .java文件先通过javac指令编译成.class文件，然后通过虚拟机jvm解释执行，通过jvm实现跨平台
2. 单线程
3. js执行队列
   1. 轮转时间片：类似吃饭，把每个任务都分成毫秒级的时间片，然后让他们抢执行队列，顺序不一定，呈现出的效果就是类似于同步执行。
4. 引入方式
   1. <script type="text/javascript" src="链接"></script>
   2. <script type="text/javascript"> 中间引入代码    </script>
## 3、变量
1. 变量名命名规则
   1. 必须以英文字母，下划线_，$开头
   2. 可以包括英文字母，下划线_，$，数字
   3. 不可以用系统的关键字、保留字
2. 原始值和引用值
   1. 原始值stack存放：number string Boolean undefined null
   2. 引用值heap存放：array object function regexp date
      1. 引用值之间相比 比的是地址，地址相同就相等
   3. 引用值原始值唯一的不同是赋值形式不同
      1. 栈内存的赋值是拷贝关系，直接在栈中存放数据，所以他们之间是互不影响的
         1. num=1 之后又给其赋值num=2，系统会把原来栈中的数值复制到新的地址，原来内存上的数值不要了，内存地址直接回收。
      2. 堆内存赋值时会在栈内存中放入堆的地址，在堆中存放数据，如果把堆上面的变量赋值给别的，此时复制其栈的地址，所以他们之间是相互影响的。
         1. a=b 此时是把b的地址赋给a
         2. a=[1,2] 此时新建了一个堆，然后把地址复制给a，不影响b的地址上的值
         3. a.push(5)此时是在堆中增加一个数字5，不是修改地址
3. 基本语法
   1. js语法错误会引发后续代码终止，但不会影响其他js代码块
      1. 低级错误（语法解析错误）
      2. 逻辑错误（标准错误）
   2. js运算符
      1. +：数学运算，字符串连接，任何东西加字符串都等于字符串
      2. i++：先计算，计算完后给其加一
      3. i--：先减一，然后计算
   3. 字符串比较
      1. 先两个字符串的第一位ascll码相比，相同的话比后面位。
      2. NaN不==任何东西,包括自己。特例。并且为逻辑false，“”也为逻辑false
      3. 字符串取值：str.charAt（0）表示取第0个字符串，但是字符串基于数组储存，可以直接str[0]
   4. 逻辑运算符
      1. &&：当只有两个表达式时，先看第一个，如果为真，则直接转换第二个表达式的结果（结果不一定只为true或false，也可能为别的，例如数字）；如果为假，直接返回第一个表达式的值。当多个表达式，同样推理，直到有假的时把假的返回
         1. 短路语句  data && 执行的语句 前面判断为true，即有数据，就可以执行后面的语句了。
      2. ||：当只有两个表达式时，先看第一个，如果为假，直接转换为第二个表达式的结果，如果为真，则转换为第一个表达式的结果
         1. 兼容， x || x 只要有一个行就行，不看后面的了
         2. function(e){ 
         非IE浏览器可以直接用这个e变量
         IE浏览器变量在window.event里
         所以event=e || window.event 写兼容
         }
      3. 与运算符碰到假就停，或运算符碰到真就停
4. 类型转换
   1. typeof六个基本类型：number、Boolean、string、undefined、function、object（有数组、null）
      1. 用法1:typeof(x);     用法2：typeof x，中间用空格替代括号
      2. 如果typeof没定义的变量，不发生错误，显示undefined
      3. typeof（typeof（undefined）） 结果为string，因为typeof返回的是字符串
   2. 显示类型转换
      1. Number（）
      2. parseInt（）数字转换为int型数字，从数字位开始看，知道非数字位截至，把其转换为整型数字。如果有两个参数时，第二个参数表示第一个参数是多少进制的，然后把第一个参数转换为十进制。
      3. parseFloat（）
      4. String（）
      5. 参数.toString：把参数转换为字符串，undefined、null不能用这个方法。如果是参数.toString（x），表示把十进制的参数转换为x进制的字符串
      6. Boolean（）
      7. isNaN（）:把里面的数字用number转换，转换完之后和nan比对
      8. +号、-号：当两边只要有一个是字符串就会调用string把两个都转变为字符串
      9. 其他大部分数学有关的都调用number
      10. 大于号、小于号、==、！=：有数字比较时，都用number转换，转换完之后比大小，数字优先
      11. undefined == null   true；   nan == nan false
      12. 不发生类型转换：=== 和 ！==
5. 函数
   1. 函数声明
      1. function word（）{}；
      2. word（）调用函数
      3. word指函数体，和c语言不通，c语言是指针
   2. 命名函数表达式 
      1. test=function abc（）{}；   
      2. test为函数，后面的为表达式，忽略abc这个名字，所以不可以直接调用abc，只能用test，去掉abc变为匿名函数，匿名函数用的多所以简称为函数表达式
      3. test.name 为abc，其作为test的名字属性存在，如果没有abc，则用本身的名字
   3. 特殊之处
      1. 形参不限制位数，天生不定参。形参多，可以，实参多，可以。
      2. arguments：实参列表
      3. 函数名.length为形参的长度
      4. 形参和arguments两个表达的是同一个变量。一个改变另一个也改变，但是是两个东西。
      5. 实参列表开始有几个就有几个，arguments数组不会增加数值，当形参多于实参并且在后面给形参赋值时，arguments是看不到变化的
6. 预编译
   1. js执行三部曲：语法分析、预编译、解释执行
   2. 函数声明整体提升、变量声明提升
   3. imply global 暗示全局变量
      1. 任何变量（不论作用域在哪），如果未经声明就赋值，此变量为全局对象（window对象）所有，变为window的一个属性。称为暗示全局变量
      2. window就是全局。全局上的任何变量，即使声明了，也为window所有，是window的一个属性。var a=123；就等同于window.a=123；
      3. window就是全局的域
      4. var a = b = 123；
         1. 这里的顺序是先把123赋值给b，然后声明a，最后把b的值赋值给a。
         2. b未经声明
   4. 函数预编译过程，在函数执行前触发预编译（四部曲，如果名称重复了只保留一个名，按四部曲执行顺序开始覆盖，并且在预编译执行过的声明在解释执行代码时不会重复执行） p12 1：00：00 
      1. 创建AO对象（也称执行期上下文） 
         1. activation object活跃对象（执行期上下文）
         2. AO { }
      2. 找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined
         1. var test=function abc（）{}；
         2. 这里的test开始算变量（var test）
         3. 在解释执行的时候只执行后面的赋值（test=function abc（）{}）
      3. 将实参和形参统一，把实参的值放入形参属性中
      4. 在函数体里面找函数声明，值赋予函数体 
   5. 同一个函数每次执行都会创建一个新的执行上下文，函数执行完毕，执行上下文被销毁
   6. 预编译不止发生在函数体里，还发生在全局，把全局看正一整个函数，区别就是没有参数，并且生成的是GO对象 global object。GO就是window。
7. 作用域链
   1. 作用域。例函数test.[ [scope] ],这个隐式属性，系统会用，但是不可以调用出来。
   2. [ [scope] ]就是作用域，其中存储了运行期上下文（AO、GO）的集合
   3. 作用域链：[ [scope] ]中存储的执行期上下文对象的集合，这个集合呈链式链接，所以称为作用域链
   4. 当在全局作用域定义一个函数（这时其作用域链只有GO），然后在后面执行这个函数前
      1. 这时形成执行上下文AO
      2. 函数的[ [scope] ]属性改变，0：GO{}；1：AO{}； 里面存的是上下文的地址
      3. 当函数调用完，属性值变为 0：GO{}； 
   5. 查找函数里面的变量时，从这个函数的作用域链顶端依次向下查找
8. 闭包
   1. 当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。
   2. ```function a（）{
            function b（）{}；
            return b；
         }
         var demo=a（）；
         demo（）；
      ```
   3. 通过把b函数返回，在清除a函数的执行上下文时，定义的b函数里面保存了a的执行上下文，后面通过b把a的执行上下文返回出来，形成闭包。即b的scope属性有a的AO
   4. 产生原因就是定义函数时，其自动产生执行上下文，为其父函数的执行上下文，并且不会清除，只有执行函数时产生的执行上下文会被清除。如果把这个函数保存到外面，可以在外面访问，那么执行上下文也就跟随保存出来了。
   5. 闭包的作用
      1. 实现公有变量,例：函数累加器
         1. ```
            function add(){
               var count=0；
               function demo(){
                  count++;
                  console.log(count);
               }
               return demo;
            }
            var counter=add();
            counter();
            ```
      2. 可以做缓存（存储结构），例：eater
      3. 可以实现封装，属性私有化。即在构造函数里定义变量，外面访问不到，里面可以通过方法使用。
      4. 模块化开发，防止污染全局变量