当设计网页时用的时百分比设置，可以为body设置一个最小宽度属性min-width: 1000px;当宽度小于这个时，窗口不会再进行缩放。还有max-width。详见p27 49：00

.movieitem:nth-child（2n）,伪类选择器，选择父元素中的第几个子元素，可以设置为2n，含义为第2n个子元素都会被设置，即2，4，6，等等元素设置样式。

.score::first-letter{}选中元素中第一个文字

line-height: 2.5;
font-size: 1.5em;

隐藏元素：display：none  不生成盒子

每个元素都具有透明通道，0~1，0表透明
rgba（红 绿 蓝 alpha（0~1））
hex：#红 绿 蓝 透明通道（00~ff）例#ff6600
# 1、元素包含关系
1. 以前块级元素可以包含行级元素，反过来不行，a元素除外，a是行级元素。
2. 现在元素的包含关系由元素的内容类别决定。例如查看h1是否可以包含p元素。直接百度h1 mdn就行。
3. 总结：
   1. 容器元素中可以包含任何元素。
   2. a元素几乎可以包含任何元素。
   3. 标题和段落元素不能包含容器元素。
# 2、为网页添加样式
1. css规则：选择器＋声明块。
2. css代码书写位置。
   1. 内部样式表：style如果放在body后面会出现开始闪烁一下，原因是开始没加载到样式代码，等加载到css代码时重新改变效果。应放在head中。
   2. 内联样式表，直接style=“”
   3. 外部样式表，写到独立的css文件中。<link rel=“stylesheet” href=> rel表示类型，样式表。
# 3、常见样式声明
1. color 预设值：单词。 三原色：红绿蓝。0~255表示。rgb（0，255，0）。hex（16进制）表示#000000，分别为红绿蓝。
2. font-size px：绝对像素。em：相对父元素像素的大小。父元素没有就向上取，直到html，如果都没有，则使用基准字号。有的元素例如h1没设置，会用user agent stylesheet 用户代理，即浏览器设置的默认样式。
3. font-weight：文字粗细程度可以取值数字或预设值。例font-weight=bold=700。
4. font-family：文字类型。必须用户计算机中存在的字体才有效。通过使用多个字体来避免。font-family：微软雅黑，Arial，sans-serif（非衬线字体类，通常计算机有默认的，即字体的边缘没有经过修饰。 衬线字体往往用于印刷，比较好看）；
5. font-style：倾斜。i元素默认倾斜字体通常用于图标，通过css设置。
6. <strong>表示重要的不能忽略的内容
   1. <em>表示强调的内容。通常斜体，可以改。
7. text-decoration：文本修饰，给文本加线。a元素默认underline，下划线。del元素，表删除的内容，line-through。s元素，过期的内容line-through。
8. text-indent：2em；首行文本缩进2字符。
9. line-height：行高。
   1.  设置行高为容器的高度，可以让单行的文本垂直居中。
   2.  行高可以设置为纯数字，表示相对于当前元素的字体大小。 
10. width，宽度。height，高度。
11. letter-sp文acing，字间隙。
12. text-align：元素内部文字水平排列方式。

# 4、选择器
1. 简单选择器
   1. ID选择器 #unique
   2. 元素选择器
   3. 类选择器 .special
   4. 通配符选择器 *选中所有元素
   5. 属性选择器 根据属性名和值选择元素 [href=“1”]{color=""}表示选中所有拥有href属性等于1的元素.
   6. 伪类选择器：选择某种元素的某种状态。如果四种状态都写注意下面顺序。
      1. link 超链接未访问状态。例a：link{}
      2. visited 超链接访问过状态。 
      3. hover 鼠标悬停状态。
      4. active 激活状态下，即鼠标按下时状态。
      5. l v h t顺序
   7. 伪元素选择器
      1. before 即在元素中生成一个子元素，且在第一位。例span::before{content:"<"}
      2. after
2. 选择器的组合
   1. 并且 例p.red 例a[]
   2. 后代元素：空格 例.red li{}
   3. 子元素 ：>   例.a>.b{}
   4. 相邻兄弟元素：+ 例.a+li{}
   5. 后边出现的所有兄弟元素：~
3. 选择器的并列
   1. 多个选择器用逗号分隔。语法糖
# 5、层叠
1. 声明冲突：同一个样式多次应用到同一个元素。层叠：解决声明冲突的过程，浏览器自动处理（权重计算）。
   1. 比较重要性。从高到低。
      1. 作者样式表（开发者书写的样式）中的！important样式。例color：red ！important；不建议用，重要性太高，不利于修改。
      2. 作者样式表中的普通样式
      3. 浏览器中的默认样式
   2. 比较特殊性。第一步没解决才会发生。
      1. 总体规则：看选择器选中的范围约窄，越特殊。
      2. 具体规则，通过选择器计算一个四位数。
         1. 如果是内联样式，千位进一。
         2. 选择器中所有id选择器的数量为百位。
         3. 选择器中所有类选择器、伪类选择器、属性选择器的数量为十位。
         4. 选择器中所有元素选择器、伪元素选择器的数量为个位。
         5. 256个才会进一，正常不考虑进位。
   3. 比较原次序。
      1. 代码书写靠后胜出。
2. 应用
   1. 重置样式表。书写一些样式覆盖浏览器的默认样式。
   2. 重置样式表覆盖浏览器样式表，然后再覆盖重置样式表。
   3. 在head中先引用重置样式表，再引用自己要用的样式表，因为优先级相同时靠后的可以覆盖前面的。
   4. 常见的重置样式表：normalize.css,reset.css,meyer.css
3. 爱恨法则
   1. link》visite》hover》active必须按顺序。
   2. 因为a:link  a：visited a：hover a：active四个原次序一样，所以当触发时总是书写靠后的胜出。
# 6、继承
1. 子元素会继承父元素某些css属性。通常和文字相关的元素都可以继承。例background-color就不能继承。
# 7.属性值的计算过程
1. 一个一个元素依次渲染，按照页面文档的树形目录结构进行。
2. 渲染每个元素的前提条件：该元素的所有css属性必须有值。
3. 一个元素从所有属性都没有值，到所有属性都有值，这个计算过程叫css属性值计算过程。共四个步骤。
   1. 确定声明值。开发者写的属性值。参考样式表中没有冲突的声明，作为css属性值。
   2. 层叠冲突。对样式表中有冲突的声明使用层叠规则，确定css属性值。
   3. 使用继承。对仍没有值的属性，若可以继承，则继承父元素的值。
   4. 使用默认值。对仍没有值的属性，使用默认值。
4. 强制继承，当元素有声明值时，通常避免浏览器默认声明值，可以通过强制继承来使其继承父元素的属性值。color:inherit;
5. color：initial；设置为初始值，设置为默认值。
# 7、盒模型
1. box：盒子，每个元素在页面中都会生成一个矩形区域（盒子）
2. 盒子类型
   1. 行盒，display=inline的元素。不换行
   2. 块盒，display=block的元素。独占一行
   3. 默认为块的元素：容器元素、p、h
   4. 常见行盒：span、a、img、video、audio、
3. 盒子的组成部分：内容、填充、边框、外边距。属性如下
   1. content：width、height，盒子内容的宽高，称作内容盒。
   2. padding：盒子边框到盒子内容的距离。padding-left、padding-right、padding-top、padding-bottom、没设置默认为0.简写属性上、右、下、左。        填充盒：内容加填充。  box-sizing：padding-box
   3. border：边框样式、宽度、颜色（border-style、border-width、border-color）边框样式默认设置为none，此时显示效果看不见。边框颜色默认为字体颜色。四个边框分别可以各自设置这三个属性，都是简写属性。例border-width：10px 11px 12px 13px； border也是一个简写属性，分别为宽度、样式、颜色。border：10px dashed red； 边框盒。
   4. margin：边框到其他盒子的距离。margin-top 等四个属性。
4. 应用
   1. 改变宽高范围：默认情况下，宽高设置的是内容盒的宽高。但衡量设计稿尺寸的时候，使用的往往是边框盒，但设置width和height，则设置的是内容盒。
      1. 办法一：精确计算
      2. 办法二：css3的属性，box-sizing：border-box；这时设置的是边框盒。
   2. 改变背景覆盖范围：默认情况下，背景覆盖边框盒。通过background-clip：content-box、padding-box修改。
   3. 溢出处理：即内容的宽高小了。通过overflow：hidden、visible、auto、scroll（滚动条）修改。也有overflow-x：和y 
   4. 断词规则：word-break：会影响文字在什么位置被截断换行。
      1. 取值：normal，普通，CJK（中日韩）字符文字位置截断，非CJK字符，单词位置截断。
      2. break-all：截断所有，所有字符都在文字处截断。
      3. keep-all：所有文字都在单词处截断。中文之间如果没空格就看成一个单词，不截断，一直在一行延申。会在空格处截断。
   4. 空白处理：
      1. *white-space：nowrap；表示不换行，仅一行。会造成溢出，设置overflow：hidden；此时有的单词显示一半，text-overflow：ellipsis；文本溢出表示为...    这里只能控制单行文本。
      2. white-space：pre；表示元素里的空白字符都会保留，不会折叠。
      3. white-space：normal；表示会折叠。默认值。
5. 行盒盒模型。
   1. 行盒居中：text-align：center
   2. 常见的行盒包含具体内容的元素。
      1. 常见特点，盒子沿着内容延申。
      2. 行盒不能设置宽高，行盒是跟着内容走的，取决于内容。调整行盒的宽高应该使用字体大小、行高、字体类型间接调整。水平通过padding设置。
      3. 内边距水平方向有效，垂直方向仅会影响背景，不会实际占据空间。
      4. 边框和内边距相同，水平有效垂直会影响背景，调整垂直方向只认行高。
      5. 外边距和内边距相同，水平有效垂直无效。
   3. 行块盒 display：inline-block的盒子。
      1. 不独占一行
      2. 盒模型中所有尺寸都有效（对比上面的行盒垂直无效、宽高无效。）
      3. 常用于做分页、
   4. 空白折叠，发生在行盒内部或行盒之间，包括行块盒。
   5. 可替换元素，非可替换元素
      1. 大部分元素，页面上显示的结果，却决于元素内容，称为非可替换元素
      2. 少部分元素，页面上显示的结果，取决于元素属性，称为可替换元素
      3. 可替换元素：img、video、audio，绝大部分为行盒，但是类似于行块盒，盒模型中所有元素都有效，宽高、边框、填充等。这时设置宽高图片会被拉长或者压缩，如果想让其按照原比例则需设置*object-fit*属性，取值
         1. contain；宽高比例不变
         2. fill；填充所有的宽高，默认设置
         3. cover；宽高比例不变，直接裁剪图片。
# 8、常规格式化模型
盒模型：规定单个盒子的规则。
常规格式化模型：页面中的多个盒子排列规则。也称为布局规则
1. 视觉格式化模型：大体将页面中盒子的排列分为三种方式：常规流，浮动，定位。
   1. 常规流（也叫文档流普通文档流）
      1. 所有元素默认情况下都是常规流排列。总体规则：块盒独占一行，行盒水平依次排列。
      2. 包含块（containing block）：每个盒子都有它的包含块，包含块决定了盒子的排列区域。
         1. *绝大部分情况下盒子的包含块为其父元素的内容区域。*
      3. 块盒
         1. 每个块盒的总宽度必须刚好等于包含块的宽度（即content）
            1. 宽度的默认值是auto：将剩余空间吸收掉。
            2. margin的取值也可以为auto，但默认值为0.
            3. 当两者都为auto，width吸收能力强，margin为0
            4. 若宽度、边框、内边距、外边距计算后仍有剩余空间，则剩余空间被margin-right全部吸收。
            5. 在常规流中，块盒在其包含块中居中，可以定宽，然后左右margin设置为auto  
            6. 也可以设置左右margin为负数，然后width会吸收，显示为超过包含块。因为其相加必须等于父元素的内容块宽度，所以就被拉长了。
         2. 每个块盒垂直方向上的auto值
            1. height：auto，默认值，适应内容高度。如果没有设置高度，其高度会随着内容被撑开。
            2. margin：auto，表示0
         3. 百分比取值
            1. padding、宽、margin可以取值为百分比，都是相对于包含块的宽度，注意是相对于  包含块  的宽度    。所有的无论是高度百分比也都是相对于包含块的宽度。
            2. 高度的百分比
               1. 包含块的高度取决于子元素的高度，即包含块没有设置高度，为auto，子元素设置为百分比，此时设置百分比无效。
               2. 包含块的高度不取决于子元素的高度，即包含块直接设置高度，此时百分比相对于父元素高度。
         4. 上下外边距的合并
            1. 两个常规流块盒，上下外边距相邻，会进行合并。两个外边距取最大值。无论是上下两个块盒上下外边距合并，或者是父子元素的上外边距重叠合并。
            2. 如果上下外边距被隔开，比如设置border，就会有两个外边距,可以通过写父元素的padding解决子元素的margin-top问题
   2. 浮动
      1. 应用场景
         1. 文字环绕
         2. 横向排列
      2. 浮动的基本特点
         1. 修改float属性值为：
            1. left：左浮动，元素靠上靠左
            2. right：右浮动，元素靠上靠右
            3. 默认值为none，不浮动
            4. 当一个元素浮动后，必定为块盒。浮动会改变其display类型。
         2. 浮动元素的包含块，和常规流一样，为父元素的内容盒。
      3. 盒子尺寸
         1. 宽度为auto时，适应内容宽度。
         2. 高度为auto时，与常规流一至，适应内容高度。
         3. margin为auto时，为0
         4. 边框、内边距、百分比设置与常规流一致
      4. 盒子排列
         1. 左浮动的盒子靠上靠左
         2. 右浮动的盒子靠上靠右
         3. 浮动盒子在包含块中排列时，会避开常规流块盒。
         4. 常规流块盒在排列时，无视浮动盒子。即其排列方式可以把前面的浮动盒子去掉来看。
         5. 行盒在排列时，会避开浮动盒子。
         6. 关系：行盒避开浮动、块盒，浮动避开块盒、行盒，块盒无视浮动
         7. 总结：行盒、浮动，比较正常，避开别的盒子，块盒无视浮动
         8. 规则：如果文字没有在行盒中，浏览器会自动生成一个行盒包裹文字。该行盒叫匿名行盒。利用这个可以做出文字环绕效果。即浮动盒子后面跟一个块盒，里面有文字。 
      5. 高度坍塌
         1. 根源：常规流盒子的自动高度，在计算时不会考虑浮动盒子，**也不会计算定位盒子**不把其当成内容。
         2. 解决方式：清除浮动，涉及css属性clear
            1. 默认值none，不清除，
            2. 值为left，清除左浮动，该元素必须出现在前面所有左浮动盒子的下方。
            3. 值为right，清除右浮动，该元素必须出现在前面所有右浮动盒子的下方。
            4. both：清除左右浮动，该元素必须出现在前面所有浮动盒子的下方。
            5. 利用一个常规流盒子元素把内容撑开
            6. 通常解决办法：把那个元素的父元素添加一个类名，例如class=contain，
            7. 然后.contain::after{content: "";display:block;clear:both;}
   3. 定位：手动控制元素在包含块中的精准位置。
      1. 涉及css属性：position，默认值：static，静态定位（不定位）。
         1. relative：相对定位
         2. absolute：绝对定位
         3. fixed：固定定位
         4. 一个元素只要position的取值不是static，就认为该元素是一个定位元素。
      2. 定位元素会脱离文档流（相对定位除外），脱离了文档流的元素，具有以下特点：
         1. 文档流中的元素摆放时，会忽略了脱离的文档流的元素。和浮动元素一样。
         2. 文档流中的元素计算自动高度时，会忽略了脱离了文档流的元素。高度坍塌
      3. 相对定位：relative
         1. 不会导致元素脱离文档流只是让元素在原来的位置上进行偏移行盒还是行盒，块盒还是块盒。
         2. 可以通过四个css属性对 设置其位置
            1. left：90px
            2. right
            3. top
            4. bottom
            5. 盒子的偏移不会对其他盒子造成任何影响。
      4. 绝对定位:absolute
         1. 盒子宽高为auto，尺寸适应内容、
         2. 包含块变化，找祖先元素中第一个定位元素（即祖先元素position值改变），该元素的填充盒为其包含块。若找不到，则他的包含块为整个网页（初始化包含块）。
         3. 通过四个css属性对 设置其相对于包含块的位置：left、right、top、bottom
      5. 固定定位：fixed
         1. 其他情况和绝对定位完全一样，只有包含块不同：固定为视口（浏览器的可视窗口）
         2. 视口和初始化包含块区别：
            1. 初始化包含块可以理解为html元素
            2. 视口是当前能看得到的区域。
            3. 有时视口大，即网页内容很少时
            4. 有时初始化包含块大，即全部的视口装不下内容区域。这时会出现滚动条
         3. 可以做出固定在视口中的位置，比如弹窗广告。无论其写在哪里。
      6. 定位下的居中
         1. 相对定位没有脱离常规流，按常规流来。
         2. 某个方向居中
            1. 定宽（高）
            2. 将左右（上下）距离设置为0
            3. 将左右（上下）margin设置为auto
            4. 绝对定位和固定定位中，margin设置为auto时，会自动吸收剩余空间。
            5. 如果设置了左边没有设置右边，由于其为auto，所以右边会直接吸收。
      7. 多个定位元素重叠时 堆叠上下文
         1. 设置z-index，通常情况下，这个值越大，越靠近用户。即元素堆叠时的处理。
         2. 只有定位元素设置z-index有效
         3. z-index可以为负数，如果是负数，遇到常规流元素浮动元素会被其覆盖。
      8. 补充
         1. 绝对定位、固定定位元素一定是块盒
         2. 绝对定位、固定定位元素一定不是浮动，会把float强势变为none
         3. 没有外边距合并