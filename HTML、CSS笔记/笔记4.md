# 1、表格元素
1. 在css技术出现之前，网页通常使用表格布局。
   1. 现在后台管理系统中可能会使用表格。
   2. 前台：面向用户的
   3. 后台：面向管理员，对界面要求不高，对功能要求高
   4. 表格的渲染速度太慢，所以不适用于网页布局。网页必须把表格所有代码全都读出来才能进行渲染
2. html元素
   ```
   <table>
      <caption>表格标题</caption>
      <thead>表头</thead>
      <tbody>表体</tbody>
      <tfoot>表位</tfoot>
    </table>
    <tr>表格行
        <th>标题单元格</th>
        <td colspan=“数字”>单元格</td>
        <td rowspan=“数字”>单元格</td>
    </tr>
    colspan属性表示跨越多少列，相当于excel中同一行的几列单元格合并。
    crowspan属性表示跨越多少行，相当于excel中同一列的几行单元格合并。
   ```
3. css属性设置
    ```
    table{
    border-collapse 边框折叠方式: separate:表示分离的 collapse:表示折叠的;
    }
    ```
# 2、其他元素
1. <abbr>表示缩写词
   1. 用法<abbr title="全称">缩写词</abbr>
2. <time>提供给浏览器或者搜索引擎用的时间
   1. 用法<time datatime="2021-4-30">今年五月</time>
   2. 没什么效果，给浏览器看的。
3. <b>以前是无语意元素，主要用于加粗字体（bold）。
   1. 想弃用，但是现在包裹文字用于语音重读。
4. <q>表示一小段引用文本。cite属性表示链接地址
5. <blockquote>表示大段引用的文本。同样有cite属性
6. <br>用于文本中换行，空元素
7. <hr>主要用于分割，出现一条线。也是空元素。现在用css
8. <meta>给网页添加源数据的，还可以用于搜索引擎优化SEO
   1. <meta name="keywords" content="在线商城">
   2. <meta name="author" content="王，15235@qq。com">
   3. <meta name="description" content="噶发发发">
9. <link>通常用于链接外部资源，如css、图标（在网页最上面的新网页弹出来时上显示的图标）
   1.  rel属性，relation，链接资源和当前网页的关系，例如css的关系为stylesheet，样式表。图标的rel属性为icon。
   2.  type属性,链接的资源的MIME类型，例如css的文件类型为text/css。可省略，自动确定。
10. at-rule：@规则，@语句，css语句，css指令。
    1.  在css文件开头可以写一些@规则
    2.  @import “路径”；
        1.  导入另外一个css文件
    3. @charset “utf-8”；
       1. 告诉浏览器该css文件，使用的字符编码集是utf-8.也可以在meta中表示
       2. 这个指令必须写到第一行
       3. 出现中文建议写
# 3、web字体和图标
1. web字体
   1. 解决用户电脑上没有安装相应字体，强制让用户下载改字体
   2. 使用@font-face{font-family=“取一个名字”，src：“url地址”}指令制作一个新字体
   3. 浏览器可以通过自动下载字体来使用，并用新取的名字来引用。
   4. 这里的字体是临时安装。关闭浏览器就没了
2. 字体图标
   1. 字体就是一个个做出来的，既然这样，那也可以把图标做成字体
   2. 把图标做成一个个字体，使用时候引用字体图标就行了
   3. 最好的网站为iconfont.cn网站
      1. 使用font-class方式使用图标
         1. 点击在线连接，把生成的css文件链接引用到html的link属性中，就完成了字体图标的加载。
         2. 使用方法：因为在css文件中已经在前面的@font-face中把字体取名为iconfont。并且已经在css文件中新建了一个类.iconfont使用这个新建的字体,这里就可以在网站上复制单个图标的类名，最终形成<i class="iconfont icon-yonghu"></i>取得用户文字图标。
         3. 既然是字体，就可以设置字体的颜色等等
         4. 使用离线方式下载到文件夹
            1. 直接点击下载至本地，把css文件下载。然后把这些文件粘贴到新建文件夹下面，直接在html中link添加文件夹中的iconfont.css进去就行。其余的文件是解决兼容性问题。
            2. 使用方法和在线的一样 
      2. 使用Unicode方式使用图标
         1. 直接点击复制代码，把@font-face指令复制下来，加入css文件头部，就可以远程读取到这个字体iconfont。也可以离线下载。
         2. 这里可以新建一个css类.iconfont{font-family:"iconfont" ；font-style:normal} 因为i默认为斜体，所以需要设置font-style
         3. 使用方法：<i class="iconfont">中间复制图标的代码例如&#xe610;（实体字符）</i>
# 4、块级格式化上下文
1. block formatting content 简称BFC，块级格式化上下文。
   1. 他是一块独立的渲染区域，它规定了在该区域中，常规流块盒的布局。
   2. 常规流块盒：
      1. 常规流块盒水平方向上，必须撑满包含块。
      2. 常规流块盒在包含块的垂直方向上依次摆放
      3. 常规流块盒若外边距无缝相邻，则进行外边距合并
      4. 常规流块盒的自动高度和摆放位置，**无视浮动元素、定位元素**。即定位元素也会发生高度坍塌。
   3. BFC渲染区域：这个区域由某个html元素创建，以下元素会在其内部创建BFC区域：
      1. 根元素，<html>元素创建的BFC区域，覆盖了网页中所有的元素
      2. 浮动和绝对定位元素
      3. overflow不等于visible的块盒，默认值为visible
   4. 不同的BFC区域，他们进行渲染时互不干扰。创建BFC的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部。具体规则：
      1. 创建BFC的元素，它的自动高度需要计算浮动元素。
         1. 目的是隔绝与外部的联系，如果高度坍塌，那么里面的元素会跑出去。提供了另一种解决高度坍塌的方法。即在高度坍塌的元素上设置一个浮动或者绝对定位，但这两种做法会改变盒子的排列方式，副作用最小的方式，改变overflow的属性，auto、scroll都行最好hidden。最好还是使用清楚浮动clear：both，专门用来解决高度坍塌的。
      2. 创建BFC的元素，他的边框盒不会与浮动元素重叠。
         1. 常规流块盒通常在遇到浮动元素时会无视，造成浮动盒子重叠在常规流块盒中，但是如果其创建了bfc，那么它会避免其内部的渲染影响到外部的浮动元素，这时会有一个效果类似于设置margin-left的效果避开左边浮动的元素。但是这时设置margin-left确实没用，这时的margin-left是相对于左边边框边缘的距离，和常规流块盒的值是一样的，而这个距离有一大部分被浮动元素占据了。如果要调整这两个的距离，应该设置浮动元素的margin-right。这时可以达成一种效果，左边的浮动元素固定，右边的创建BFC元素的宽度自动适应。
      3. 创建BFC的元素，不会和它的子元素进行外边距合并。
         1. 即处在不同的BFC元素中他们的外边距不可能合并。只有在同一个BFC中，才可能外边距合并
# 5、布局
1. 两栏布局
   1. 一个左浮动一个右浮动，解决高度坍塌的问题。
   2. 一般侧边栏会定宽，主区域可以定宽也可以不定宽，和设计师沟通一般主区域高度自适应内容，宽度不一定，如果是不定宽的，这时主区域不设置右浮动，设置overflow：hidden，接到前面的常规流盒子
2. 三栏布局
   1. 左右浮动，并且要解决高度坍塌的问题。
   2. 中间主区域是块盒，占据整个空间无视浮动，造成左右浮动会遮挡一部分块盒的效果，接到前面的常规流盒子。设置主区域overflow：hidden，创建bfc，让其避开浮动盒子
3. 等高要求
   1. 通常主区域内容多，处理侧边栏问题。
   2. 方法一：css3的弹性盒
   3. 方法二：js
   4. 方法三：伪等高
      1. 设置height：10000px，margin-bottom：-9990px。这时侧边栏的高度实际上很小，因为侧边栏高度坍塌，靠容器元素（包含了两栏）的：：after撑开其高度，实际上侧边栏的高度只有10px，：：after的位置是在主区域的最低处开始的。超出的区域通过侧边栏和主区域的容器设置overflow：hidden就行了。
      2. 缺点，主区域内容少的时候侧边栏多于主区域的部分就会被隐藏
4. 元素书写顺序
   1. 如果先写常规流后写浮动的话，常规流撑满区域，浮动区域就会避开常规流，在常规流下面显示。需要先写浮动，再写常规流，常规流无视浮动并且行盒避开浮动。
   2. 缺点，搜索引擎从上往下读代码，忽略css代码，只读html代码，代码越靠前越重要。这时要求主区域要靠前。
   3. 解决办法，主区域靠前，并且不需要设置为bfc了，设置margin：0 300px；把左右的空间留出来，侧边栏不写浮动，设置为绝对定位，外层容器相对定位，left：30px；top：30px；，这里的30px考虑到容器的填充区域
      1. 缺点，外层容器不知道绝对定位元素的高度，因为绝对定位元素彻底脱离了常规流，所以无法适应其高度，效果显示为侧边栏区域超出容器区域，如果侧边栏没有主区域高，那就可以
5. 后台页面的布局
   1. 特点，整个页面固定，刚好把窗口撑满，然后里面左、右边区域可以滚动，
   2. 首先把body外边距默认值给去掉。margin：0；保证整个网页刚好撑满窗口。
   3. 设置容器盒子position：fixed，设置宽度、高度100%，
   4. 设置header头部菜单栏，一般定高。这时下面的区域不好设置恰好填充所有的剩余区域。
   5. 设置下边的区域宽、高为100%。设置header区域position：absolute；因为容器为fixed，设置其宽100%，left、top为0。这时因为header为绝对定位，所以常规流盒子会忽略header，达到下边的区域覆盖容器盒子的效果，同时也覆盖了header元素。
   6. 这时下边区域会被header遮住，设置其padding-top为header的高度，因为其height设置的100%，所以需要设box-sizing：border-box
   7. 然后下面再设置左右边，这是不需要搜索引擎优化了。滚动条：overflow：auto
# 6、扩展
1. 浮动的细节规则 规则如下：
   1. 左浮动向上向左排列，右浮动向上向右排列。
   2. 浮动盒子的顶边不得高于上一个盒子的顶边。
   3. 若剩余空间无法放下盒子，则浮动盒子向下移动直到具备足够的空间能容纳盒子，然后再从左向右移动。
2. 行高的取值line-height
   1. px，像素值
   2. 无单位的数字，先继承，再计算。2表示2em，这时可以解决继承的问题。
   3. em单位：字体大小的单位，1em表示当前元素本身字体大小。先计算像素值，然后再继承。即如果在父元素上设置了2em，则会先计算父元素的像素值，然后后面子元素继承其像素值，这时如果子元素字体大小不同时，则会拥有相同的行高。
   4. 百分比。200%就是2em
3. body的背景
   1. 背景颜色
      1. 画布canvas，一块区域，用来填充背景。特点如下
         1. 最小宽度为视口宽度
         2. 最小高度为视口高度
      2. html元素的背景
         1. 覆盖画布。
      3. body元素的背景
         1. 如果html元素有背景：body元素正常（背景覆盖边框盒）
         2. 如果html元素没有背景，body元素的背景覆盖画布
         3. 目的：总会设置整个网页的背景
   2. 画布背景图片
      1. 整体规则和背景颜色一样。 
      2. 背景图的宽度百分比是相对于视口的，不是相对于画布。但是背景颜色就是相对于画布的。
      3. 背景图的高度百分比，相对于html元素，网页高度，而不是画布高度，不是视口高度。
      4. 预设值：background-position：right center。背景图横向上位置的百分比、预设值都是相对于视口的位置。背景图的纵向位置百分比、预设值都是相对于网页高度
      5. 除非给html元素设置，body元素变正常，否则背景图片都是不正常的
# 7、行盒的垂直对齐
1. 多个行盒垂直方向上的对齐
   1. 给没有对齐的元素设置vertical-align属性
   2. 属性值有预设值（top、bottom、middle、text-top、text-bottom、super、sub）和数值（-5px）、百分比两种
2. 图片的底部白边
   1. 图片的父元素是一个块盒，块盒高度自动，图片底部和父元素底边之间往往会出现空白。不加边框不容易看出来
   2. 设置父元素的字体大小为0px。自然就不存在基线了。副作用：如果父元素中其他元素含有文字就看不见了，只能看见图片。不仅仅因为其继承父元素字体大小，即使给它设置字体大小也看不见
   3. 将图片设置为块盒，块盒没有参考线，随意不会基线对齐
# 8、参考线-入理解字体
1. 文字 
   1. 文字是通过文字制作软件如fontforge制作来的，文字可以理解为一个个图片。制作文字时，会有几根参考线，只有行盒才有参考线，而文字自带行盒，不同文字类型参考线不同，同一种类型参考线一致。
   2. 一共有五根基线，位置不是平均分配，起到文字对齐的作用
      1. ——————top，顶边
      2. ——————text top，ascent，顶线
      3. ——————super，上基线
      4. ——————baseline，基线
      5. ——————sub，下基线
      6. ——————text bottom，descent，底线 
      7. ——————bottom，底边
2. font-size字体大小
   1. 字体大小设置的是文字的相对大小
   2. 文字的相对大小（em-size）：1000、2048、1024
      1. 文字顶线到底线的距离，是文字的实际大小（content-area，内容区）
      2. 假如设置的相对大小为2048，但是实际上文字大小不是这么大，例如实际大小可能是2398，当我们文字的相对大小为2048，这时设置200px，则实际大小为2398/2048*200
      3. 行盒的背景覆盖内容区content-area
3. 行高
   1. 顶线向上延申的空间，和底线向下延申的空间两个空间相等。该空间叫gap，默认情况下是字体设计者决定的。即再添加两个线top、bottom
   2. top到bottom，叫做virtual-area虚拟区，就是行高
   3. 设置行高，间接设置的就是gap，因为文字大小确定，就是顶线到底线的距离
      1. line-height：normal，默认值，使用文字默认的gap
      2. line-height：1，使用字体的相对大小作为行高，但是字体的实际大小一般都比相对大小大一部分，这时行高的gap小于0，形成字体背景超出包裹其的行盒的效果。
      3. 推荐行高保持其设计者的默认值。因为设计者会考虑这种情况。
      4. 字体之间的空隙不能消除，因为设置的行高不能做到和字体的实际大小一样，不同字体实际大小不同，所以做不到
4. vertical-align
   1. 决定参考线：font-size、font-family、line-height
   2. 一个元素如果子元素出现行盒，该元素内部也会出现参考线。由于元素不同参考线不同，对齐方式有多种。设置子元素的vertical-align
      1. baseline：默认值，该元素和父元素的参考线对齐方式为基线对齐
      2. super：该元素的基线与父元素的上基线对齐
      3. sub：该元素的基线与父元素的下基线对齐
      4. text-top：该元素的顶边top与父元素的顶线text-top对齐
      5. text-bottom:该元素的底边bottom与父元素的底线text-bottom对齐
      6. top：该元素的顶边top与line-box顶边top对齐（该行中的最高顶边）
      7. bottom：该元素的底边bottom与line-box底边bottom对齐（该行中的最低低边）
      8. middle：该元素的中线（content-area的一半），与父元素的X字母高度（在父元素的上下基线中写一个X）一半的位置对齐。
      9. 行盒组合起来可以形成多行，每一行的区域叫line-box，（行盒：inline-box）line-box的顶边是该行内所有行盒最高顶边，底边是该行内所有行的最低底边。
      10. 实际上，一个元素的实际占用高度（高度自动），高度的计算通过line-box计算。即一个元素的高度等于所有行的line-box相加。
      11. 数值：因为是基线对齐，所以相对于原来最开始的基线的偏移量，向上为正，向下为负
      12. 百分比：相对于基线的偏移量百分比是相对于自身的vertical-area高度
   3. line-box是承载内容的必要条件，没有行框文字无法显示。以下情况不生成行框：
      1. 某元素内部没有任何行盒
      2. 某元素字体大小为0
5. 可替换元素和行块盒的基线
   1. 图片的基线位于图片的下外边距。
      1. 解决图片底部白边的问题可以用以上提到的三种方法解决，但是如果设置vertical-align：bottom方式解决，不太好，因为父元素本身的参考线大概是继承自浏览器，如果图片很小时，虽然底边没了，但是父盒子的上面要大于图片，上面又出现白边了。
      2. 只有设置图片为块盒，父元素的子元素不是行盒，所以父元素也不是行盒，就不存在对齐的问题了。
   2. 表单元素的基线位置在内容的底边
   3. 行块盒
      1. 行块盒最后一行有line-box，用最后一行的基线作为整个行块盒的基线
      2. 如果行块盒内部最后一行没有行盒，则使用下外边距作为基线